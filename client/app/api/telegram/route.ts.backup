import { NextRequest, NextResponse } from 'next/server';
import telegramClientService from '@/lib/telegram-client';

// Store user sessions and OTP codes (in production, use Redis or database)
const sessionStore = new Map<string, { session: string; user: any; authenticated: boolean }>();
const otpStore = new Map<string, { code: string; expiry: number; phoneCodeHash: string }>();

export async function POST(request: NextRequest) {
  try {
    const { action, phoneNumber, otpCode, session } = await request.json();

    switch (action) {
      case 'send-otp': {
        if (!phoneNumber || phoneNumber.length < 10) {
          return NextResponse.json({
            success: false,
            message: 'Please provide a valid phone number'
          }, { status: 400 });
        }

        console.log(`üîÑ Sending OTP to ${phoneNumber}...`);

        const result = await telegramClientService.sendCode(phoneNumber);
        
        if (result.success) {
          // Store the phone code hash for verification
          otpStore.set(phoneNumber, {
            code: 'GENERATED', // The actual code is sent via Telegram
            expiry: Date.now() + 5 * 60 * 1000, // 5 minutes
            phoneCodeHash: result.phoneCodeHash!
          });

          console.log(`‚úÖ OTP sent successfully to ${phoneNumber}`);
          
          return NextResponse.json({
            success: true,
            message: 'Verification code sent to your Telegram account. Please check your messages.',
            phoneCodeHash: result.phoneCodeHash
          });
        } else {
          console.error(`‚ùå Failed to send OTP to ${phoneNumber}:`, result.error);
          
          return NextResponse.json({
            success: false,
            message: result.error || 'Failed to send verification code',
            errorType: 'OTP_SEND_FAILED'
          }, { status: 400 });
        }
      }

      case 'verify-otp': {
        if (!phoneNumber || !otpCode) {
          return NextResponse.json({
            success: false,
            message: 'Phone number and OTP code are required'
          }, { status: 400 });
        }

        if (otpCode.length !== 6 || !/^\d{6}$/.test(otpCode)) {
          return NextResponse.json({
            success: false,
            message: 'Please enter a valid 6-digit code'
          }, { status: 400 });
        }

        const storedOtp = otpStore.get(phoneNumber);
        if (!storedOtp) {
          return NextResponse.json({
            success: false,
            message: 'No verification code found. Please request a new code.'
          }, { status: 400 });
        }

        if (Date.now() > storedOtp.expiry) {
          otpStore.delete(phoneNumber);
          return NextResponse.json({
            success: false,
            message: 'Verification code expired. Please request a new code.'
          }, { status: 400 });
        }

        console.log(`üîÑ Verifying OTP for ${phoneNumber}...`);

        const authResult = await telegramClientService.signIn(phoneNumber, otpCode, storedOtp.phoneCodeHash);
        
        if (authResult.success) {
          // Store user session
          const userSession = {
            session: authResult.user!.session,
            user: authResult.user,
            authenticated: true
          };
          
          sessionStore.set(phoneNumber, userSession);
          otpStore.delete(phoneNumber); // Clean up OTP

          console.log(`‚úÖ User authenticated successfully: ${phoneNumber}`);
          
          return NextResponse.json({
            success: true,
            message: 'Phone number verified successfully!',
            user: authResult.user,
            session: authResult.user!.session
          });
        } else {
          console.error(`‚ùå OTP verification failed for ${phoneNumber}:`, authResult.error);
          
          return NextResponse.json({
            success: false,
            message: authResult.error || 'Invalid verification code',
            errorType: 'OTP_VERIFICATION_FAILED'
          }, { status: 400 });
        }
      }

      case 'get-chats': {
        if (!session) {
          return NextResponse.json({
            success: false,
            message: 'Authentication required. Please verify your phone number first.'
          }, { status: 401 });
        }

        console.log(`üîÑ Fetching chats for session...`);

        try {
          const chats = await telegramClientService.getDialogs(session);
          
          console.log(`‚úÖ Found ${chats.length} chats`);
          
          return NextResponse.json({
            success: true,
            chats: chats.map(chat => ({
              id: chat.id.toString(),
              name: chat.title,
              members: chat.membersCount || 0,
              type: chat.type
            }))
          });
        } catch (error: any) {
          console.error('‚ùå Error fetching chats:', error);
          
          return NextResponse.json({
            success: false,
            message: 'Failed to fetch chat rooms. Please try again.',
            errorType: 'CHATS_FETCH_FAILED'
          }, { status: 500 });
        }
      }

      case 'get-messages': {
        const { chatId, limit = 50 } = await request.json();
        
        if (!session) {
          return NextResponse.json({
            success: false,
            message: 'Authentication required'
          }, { status: 401 });
        }

        if (!chatId) {
          return NextResponse.json({
            success: false,
            message: 'Chat ID is required'
          }, { status: 400 });
        }

        console.log(`üîÑ Fetching messages from chat ${chatId}...`);

        try {
          const messages = await telegramClientService.getMessages(parseInt(chatId), limit, session);
          
          console.log(`‚úÖ Found ${messages.length} messages in chat ${chatId}`);
          
          return NextResponse.json({
            success: true,
            messages: messages.map(msg => ({
              id: msg.id,
              text: msg.message,
              from: msg.fromName || `User${msg.fromId}`,
              date: new Date(msg.date).toISOString(),
              chatId: msg.chatId,
              chatTitle: msg.chatTitle
            }))
          });
        } catch (error: any) {
          console.error(`‚ùå Error fetching messages from chat ${chatId}:`, error);
          
          return NextResponse.json({
            success: false,
            message: 'Failed to fetch messages',
            errorType: 'MESSAGES_FETCH_FAILED'
          }, { status: 500 });
        }
      }

      case 'search-messages': {
        const { query, chatId } = await request.json();
        
        if (!session) {
          return NextResponse.json({
            success: false,
            message: 'Authentication required'
          }, { status: 401 });
        }

        if (!query || query.trim().length < 2) {
          return NextResponse.json({
            success: false,
            message: 'Search query must be at least 2 characters long'
          }, { status: 400 });
        }

        console.log(`üîÑ Searching messages for: "${query}"${chatId ? ` in chat ${chatId}` : ' globally'}...`);

        try {
          const messages = await telegramClientService.searchMessages(query, chatId ? parseInt(chatId) : undefined, session);
          
          console.log(`‚úÖ Found ${messages.length} messages matching "${query}"`);
          
          return NextResponse.json({
            success: true,
            messages: messages.map(msg => ({
              id: msg.id,
              text: msg.message,
              from: msg.fromName || `User${msg.fromId}`,
              date: new Date(msg.date).toISOString(),
              chatId: msg.chatId,
              chatTitle: msg.chatTitle
            })),
            query: query,
            resultsCount: messages.length
          });
        } catch (error: any) {
          console.error(`‚ùå Error searching messages:`, error);
          
          return NextResponse.json({
            success: false,
            message: 'Failed to search messages',
            errorType: 'SEARCH_FAILED'
          }, { status: 500 });
        }
      }

      case 'get-user-info': {
        if (!session) {
          return NextResponse.json({
            success: false,
            message: 'Authentication required'
          }, { status: 401 });
        }

        try {
          const user = await telegramClientService.getMe(session);
          
          if (user) {
            console.log(`‚úÖ User info retrieved: ${user.first_name} (${user.phone})`);
            
            return NextResponse.json({
              success: true,
              user: {
                id: user.id,
                firstName: user.first_name,
                username: user.username,
                phone: user.phone,
                isPremium: user.is_premium || false
              }
            });
          } else {
            return NextResponse.json({
              success: false,
              message: 'User not found'
            }, { status: 404 });
          }
        } catch (error: any) {
          console.error('‚ùå Error getting user info:', error);
          
          return NextResponse.json({
            success: false,
            message: 'Failed to get user information',
            errorType: 'USER_INFO_FAILED'
          }, { status: 500 });
        }
      }

      case 'start-monitoring': {
        const { chatIds } = await request.json();
        
        if (!session) {
          return NextResponse.json({
            success: false,
            message: 'Authentication required'
          }, { status: 401 });
        }

        if (!chatIds || !Array.isArray(chatIds) || chatIds.length === 0) {
          return NextResponse.json({
            success: false,
            message: 'At least one chat ID is required for monitoring'
          }, { status: 400 });
        }

        console.log(`üîÑ Starting real-time monitoring for chats: ${chatIds.join(', ')}`);

        try {
          // Start monitoring (this would set up webhooks or long polling in production)
          await telegramClientService.startMessageMonitoring(chatIds, (message) => {
            console.log(`üì® New message in chat ${message.chatId}: ${message.message}`);
            // Here you would typically emit to WebSocket or save to database
          });

          console.log(`‚úÖ Monitoring started for ${chatIds.length} chats`);
          
          return NextResponse.json({
            success: true,
            message: `Started monitoring ${chatIds.length} chat(s)`,
            monitoringChats: chatIds
          });
        } catch (error: any) {
          console.error('‚ùå Error starting monitoring:', error);
          
          return NextResponse.json({
            success: false,
            message: 'Failed to start message monitoring',
            errorType: 'MONITORING_FAILED'
          }, { status: 500 });
        }
      }

      default: {
        return NextResponse.json({
          success: false,
          message: 'Invalid action specified',
          availableActions: ['send-otp', 'verify-otp', 'get-chats', 'get-messages', 'search-messages', 'get-user-info', 'start-monitoring']
        }, { status: 400 });
      }
    }

  } catch (error: any) {
    console.error('üö® Telegram API Error:', error);
    
    return NextResponse.json({
      success: false,
      message: 'Internal server error occurred',
      errorType: 'INTERNAL_ERROR',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    }, { status: 500 });
  }
}

// GET endpoint for health check and status
export async function GET(request: NextRequest) {
  return NextResponse.json({
    success: true,
    message: 'Telegram API service is running',
    endpoints: {
      'POST /api/telegram': 'Main API endpoint',
      'Actions supported': [
        'send-otp - Send verification code to phone number',
        'verify-otp - Verify OTP and authenticate user',
        'get-chats - Get user\'s chat rooms/channels',
        'get-messages - Get messages from specific chat',
        'search-messages - Search messages by query',
        'get-user-info - Get authenticated user information',
        'start-monitoring - Start real-time message monitoring'
      ]
    },
    timestamp: new Date().toISOString()
  });
}
